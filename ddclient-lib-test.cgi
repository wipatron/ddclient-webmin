#!/usr/bin/perl

# A simple unit testing page, done this way as some functions
# require webmin functionality  

require './ddclient-lib.pl';

&ui_print_header($text{'index_log'},
                 $text{'index_title_main'},
                 undef,
                 undef,
                 undef,
                 0,
                 1,
                 &help_search_link("ddclient", "man", "doc", "google"), 
                 undef, undef, undef);
print "Testing parser: <br>";
my $err = test_parse();
print 'test_parse(): <span style="color: ' . ($err ? 'red' : 'green') . '">' . ($err ? 'fail' : 'pass') . '</span>';

print "<br/><br/>Testing writer: <br>";
$err = test_parse_write_parse();
print 'test_parse_write_parse(): <span style="color: ' . ($err ? 'red' : 'green') . '">' . ($err ? 'fail' : 'pass') . '</span>';

# Test the parser function
sub test_parse() {
	open PARSE_TEST, ">", "/tmp/parse_test";
	print PARSE_TEST <<FI
# Generated by Webmin ddclient module
# Sat Mar  7 10:31:17 CET 2009
#
protocol=bladie
file=/etc/ddclient.conf
use=if, if=eth0
fw-skip='bla , ', web-skip="bli , "

protocol=dyndns2, \\
server=members.dyndnfs.org, \\
login=qwerty, \\
password=qwerty \\
sihaya.dnsalias.com

protocol=5dyndns5, \\
server=members.5dyncs.org, \\
login=mylogin, \\
password=mypassword, \\
use=if, if=eth0, \\
host=ourfirstdomain.com, second.domain.ce, 123456 usern passw
	
FI
;
	close PARSE_TEST;
	
	my $result = ddclient_conf_parse_multi("/tmp/parse_test");
		
	return check_results($result);
}

sub test_parse_write_parse() {
	ddclient_select_options();
	
	my $result = ddclient_conf_parse_multi("/tmp/parse_test");
	if (check_results($result)) {
		return 1;
	}
	
	ddclient_config_save_multi($result, "/tmp/parse_test");
	$result = ddclient_conf_parse_multi("/tmp/parse_test");
	
	return check_results($result);	
}

sub check_results {
	my $result = shift;
	my %result_options = ('fw-skip'=>'bla , ', 'web-skip'=>'bli , ', 'file'=>'/etc/ddclient.conf', 
		'use'=>'if', 'protocol'=>'bladie', 'if'=>'eth0');
	
	if (test_equal_hash("globals", \%result_options, $result)) {
		return 1;
	}
	
	my @services = @{$result->{'services'}};
	if (@services != 2) {
		print "Expected 2 services<br>";
		return 1;
	}
	
	if (@{$services[0]->{'hostnames'}} != 1) {
		print "First service should have one hostname<br>";
		return 1;
	}
	
	if (@{$services[1]->{'hostnames'}} != 3) {
		print "Second service should have three hostnames<br>";
		return 1;
	}
	
	if ($services[1]->{'hostnames'}->[2] != 123456) {
		print "Second service third hostname should be 123456: not ";
		return 1;
	}
	
	if (test_equal_hash("service 0",
		{'protocol'=>'dyndns2', 'server'=>'members.dyndnfs.org', 'login'=>'qwerty', 'password'=>'qwerty'},
		$services[0])) {
			return 1;
	}
		
	if (test_equal_hash("service 1", 
		{'protocol'=>'5dyndns5', 'server'=>'members.5dyncs.org', 'login'=>'usern', 'password'=>'passw', 
			'use'=>'if', 'if'=>'eth0'
		}, $services[1])) {
		return 1;			
	}
}


# First hash is the reference other are the actual vals
sub test_equal_hash($$) {
	my ($what, $refer, $resu) = @_;
	
	my %result_options = %{$refer};
	my %result = %{$resu};
	
	my $result_n = 0;
	foreach my $key (keys %result) {
		if ($key eq 'services' || $key eq 'hostnames') {
			next;
		}
		
		$result_n++;
		if (!exists($result_options{$key})) {
			print "Unknown key: $key for $what<br>";
			return 1;
		}
		elsif ($result_options{$key} ne $result{$key}) {			
			print "Values not equal for key=$key in $what: $result_options{$key} != " . $result{$key} . "<br>";
			return 1;
		}
	}
	
	foreach my $key (keys %result_options) {
		if (!exists($result{$key})) {
			print "No value for key: $key for $what<br>";
			return 1;
		}
	}
	
	if ($result_n != keys %result_options) {
		print "Not enough keys in result: $what" . $result_n . 
				" != " . (keys %result_options) . "<br>";
		return 1;
	}
}